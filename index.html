<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="style.css">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>
<body>

<h1>Shape Clicker</h1>
<div id="score"> Score: 0</div> 
<div id="multiplier">×1</div>

<button onclick="addPoint()">Click Me!</button>
<!-- <a href="https://ayzombie.github.io/LAG-MACHINE/" target="_blank">
  <button>click me for 69 quintillion score!</button>
</a> -->
<div id="cps">CPS: 0</div>

<div class="shop">
  <h2>Shop</h2>
  <button id="upgradeBtn" onclick="buyUpgrade()">Upgrade Click (+1) — Cost: 10</button>
  <button id="autoClickerBtn" onclick="buyAutoClicker()">Upgrade Speed — Cost: 50</button>
  <button id="ballSpawnerBtn" onclick="buyBallSpawner()">Add Ball — Cost: 100</button>
  <button id="squareSpawnerBtn" onclick="buySquareSpawner()">Add Square — Cost: 200</button>
  <button id="triangleSpawnerBtn" onclick="buyTriangleSpawner()">Add Triangle — Cost: 500</button>
  <button id="incomeBtn" onclick="buyIncome()">Increase Value — Cost: 1000</button>
  <button id="rebirth" onclick="rebirth()">REBIRTH — COST: 1000000</button>
  <button onclick="restartGame()">Restart Game</button>

</div>

<div id="sidebar">
  <label for="num">Enter a Number for Gifts!</label>
  <input type="number" id="num" placeholder="Type a number">
  <button id="submit">Submit</button>
</div>
<canvas id="gameCanvas"></canvas>

<p id="pathLabel"> PATHS: </p>

<button id="waterPathBtn" onclick="waterPath()">Water Path</button>

<button id="MoreUpgradesButton" onclick="showButtons()">Paths</button>
<button id="rain" onclick="buyRain()">Rain - Cost: 1000000</button>
<button id="snakeBtn" onclick="buySnake()">Snake — Cost: 4000000</button>
<button id="cloudsBtn" onclick="buyClouds()">Clouds — Cost: 5000000</button>
<button id="sharkSpawnerBtn" onclick="buySharkSpawner()">Add Shark — Cost: 15000000</button>
<button id="lightningBtn" onclick="buyLightning()">Lightning — Cost: 20000000</button>
<button id="lightningUpgradeBtn" onclick="upgradeLightning()">Upgrade Lightning — Cost: 60000000</button>

<script>  //start of javascript variables!!!!!!!  
if ('scrollRestoration' in history) {   // to go to top when start
  history.scrollRestoration = 'manual';
}

window.onload = function() {
  window.scrollTo(0, 0);
};

const SAVE_VERSION = "1.0"; // bump this whenever you want a reset

let pickedWater = false;

let score = 0;
// CPS tracking (declare once)
let cps = 0;
let cpsHistory = [];
let pointsThisInterval = 0; 
// get the CPS element (your HTML uses id="cps")
const cpsEl = document.getElementById("cps");

let pointsPerClick = 1;
let upgradeCost = 10;

let autoClickerLevel = 1;
let autoClickerCost = 50;

let ballSpawnerCount = 0;
let ballSpawnerCost = 100;
let squareValue = 2;

let squareSpawnerCount = 0;
let squareSpawnerCost = 200;

let triangleSpawnerCount = 0;
let triangleSpawnerCost = 500;
let triangleValue = 5;

let incomeCost = 1000;
let income = 1;

let sharkSpawnerCount = 0;
let sharkSpawnerCost = 15000000; // adjust price
let sharkValue = 1000;        // points per bounce

let balls = [];
let squares = [];
let triangles = [];
let popups = [];
let raindrops = [];
let sharks = [];
let clouds = [];
let lightnings = [];

let rebirthCost = 100000;
let growingCostMulti = 1.5;
let multi = 1;

let pickedPath = false;
let unlockedMoreUpgrades = false;
let rainSpeed = 100;
let boughtRain = false;
let rainInterval = null;
let snake = null;
let boughtSnake = false;
let snakeSpawnerCost = 4000000;
let boughtClouds = false;
let boughtLightning = false;
let lightningInterval = 0.01;
let upgradedLightning = false;

let shockedMultiplier = 50;

let prestigeLevel = 0;        // how many times prestiged
let prestigePoints = 0;       // total prestige points earned
let prestigeBonus = 1;        // multiplier to everything from prestige
let prestigeCost = 1e8;       // base cost to prestige (100 million, adjust as needed)

document.getElementById("pathLabel").style.display = "none";  //PATHS: label
document.getElementById("waterPathBtn").style.display = "none";

document.getElementById("MoreUpgradesButton").style.display = "none";
document.getElementById("rain").style.display = "none";
document.getElementById("snakeBtn").style.display = "none";
document.getElementById("cloudsBtn").style.display = "none";
document.getElementById("sharkSpawnerBtn").style.display = "none";
document.getElementById("lightningBtn").style.display = "none";
document.getElementById("lightningUpgradeBtn").style.display = "none";

const input = document.getElementById("num");
const button = document.getElementById("submit");
const output = document.getElementById("output");
button.addEventListener("click", () => {                                                                             //cheat codes!!!!
  let value = Number(input.value);
  if (value === 1111) {
    score += 5000000000;
    updateScore();
  }
  input.value = "";
});
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

//track mouse
let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

//cps
  setInterval(() => {
    cpsHistory.push(pointsThisInterval);
    if (cpsHistory.length > 5) cpsHistory.shift(); // keep last 5 seconds
    cps = pointsThisInterval * 2;
    cps = formatNumber(cps);
    document.getElementById("cps").innerText = "CPS: " + cps;
    pointsThisInterval = 0;
  }, 500);

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = document.body.scrollHeight; // instead of window.innerHeight
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

//popup thing
class Popup {
  constructor(x, y, value) {
    this.x = x;
    this.y = y;
    this.value = value;
    this.alpha = 1;
    this.dy = -1.5; // moves up
    this.fontSize = 20; // start font size
  }

  update() {
    this.y += this.dy;
    this.alpha -= 0.02; // fade out
    this.fontSize += 0.3; // optional: grow effect
  }

  draw() {
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = "red";
    ctx.font = `${this.fontSize}px Arial`;
    ctx.fillText("+" + formatNumber(Math.floor(this.value)), this.x, this.y);
    ctx.globalAlpha = 1;
  }
}
// ----- BALL -----
class Ball {
  constructor(
    x = canvas.width / 2 + (Math.random() - 0.5) * 300,
    y = canvas.height / 2 + (Math.random() - 0.5) * 500,
    dx = null, dy = null) {
    this.x = x;
    this.y = y;
    this.electrified = false;
    this.dx = dx !== null ? dx : (Math.random() * 2 - 1) * autoClickerLevel;
    this.dy = dy !== null ? dy : (Math.random() * 2 - 1) * autoClickerLevel;
    this.radius = 15;
  }

  update() {
    this.x += this.dx;
    this.y += this.dy;

    if (this.x <= 0 || this.x >= canvas.width) {
      this.dx *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
    if (this.y <= 0 || this.y >= canvas.height) {
      this.dy *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
  }

  draw() {
    ctx.beginPath();

    if (this.electrified) {
      ctx.save();
      ctx.shadowColor = "red";
      ctx.shadowBlur = 50; // steady glow
      ctx.fillStyle = "#ff2222"; // neon red glow
    } else {
      ctx.fillStyle = "#ff988e"; // normal ball color
    }

    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();

    if (this.electrified) {
      ctx.restore();

      // Extra inner glow layer (steady)
      ctx.save();
      ctx.shadowColor = "white";
      ctx.shadowBlur = 40;
      ctx.fillStyle = "#ff2222";
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    ctx.closePath();
  }
}
// ----- SQUARE -----
class Square {
  constructor(
    x = canvas.width / 2 + (Math.random() - 0.5) * 300,
    y = canvas.height / 2 + (Math.random() - 0.5) * 500,
    dx = null, dy = null) {
    this.x = x;
    this.y = y;
    this.electrified = false;
    this.dx = dx !== null ? dx : (Math.random() * 2 - 1) * autoClickerLevel * 1.2;
    this.dy = dy !== null ? dy : (Math.random() * 2 - 1) * autoClickerLevel * 1.2;
    this.size = 25;
  }

  update() {
    this.x += this.dx;
    this.y += this.dy;

    if (this.x <= 0 || this.x + this.size >= canvas.width) {
      this.dx *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
    if (this.y <= 0 || this.y + this.size >= canvas.height) {
      this.dy *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
  }

  draw() {
    if (this.electrified) {
      ctx.save();
      ctx.shadowColor = "#0ff"; // simple cyan glow
      ctx.shadowBlur = 15;       // small blur, less lag
      ctx.fillStyle = "#66ffff"; // slightly light base
      ctx.fillRect(this.x, this.y, this.size, this.size);
      ctx.restore();

      // core square
      ctx.fillStyle = "#66ffff"; // dark cyan
      ctx.fillRect(this.x, this.y, this.size, this.size);
    } else {
      ctx.fillStyle = "#3399cc"; // normal dark cyan
      ctx.fillRect(this.x, this.y, this.size, this.size);
    }
  }
}
// ----- TRIANGLE -----
class Triangle {
  constructor(
    x = canvas.width / 2 + (Math.random() - 0.5) * 300,
    y = canvas.height / 2 + (Math.random() - 0.5) * 500,
    dx = null, dy = null) {
    this.electrified = false;
    this.x = x;
    this.y = y;
    this.dx = dx !== null ? dx : (Math.random() * 2 - 1) * autoClickerLevel * 1.5;
    this.dy = dy !== null ? dy : (Math.random() * 2 - 1) * autoClickerLevel * 1.5;
    this.size = 30; // side length
  }

  update() {
    this.x += this.dx;
    this.y += this.dy;

    if (this.x <= 0 || this.x + this.size >= canvas.width) {
      this.dx *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
    if (this.y <= 0 || this.y + this.size >= canvas.height) {
      this.dy *= -1;
      let gained = income * multi;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
    }
  }

  draw() {
    ctx.beginPath(); // always start a new path

    if (this.electrified) {
      ctx.save();
      ctx.shadowColor = "#ffff99";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "#ffff99";
    } else {
      ctx.fillStyle = "#ffa500"; // normal triangle color
    }

    // draw triangle
    ctx.moveTo(this.x, this.y);                        // top point
    ctx.lineTo(this.x - this.size / 2, this.y + this.size);
    ctx.lineTo(this.x + this.size / 2, this.y + this.size);
    ctx.closePath();
    ctx.fill();
    if (this.electrified) {
      ctx.restore();
    }
  }
}
//. ------ RAINDROP THING -------
class Raindrop {
  constructor() {
    this.x = Math.random() * canvas.width;
    this.y = 0; // start at top
    this.width = 5;
    this.height = 10;
    this.speed = Math.random() * 3 + 2; // 2-5 px per frame
  }

  update() {
    this.y += this.speed;

    // If raindrop hits the bottom
    if (this.y + this.height >= canvas.height) {
      const gained = 5 * multi * income;  // 1 point per drop, scaled by multiplier
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      updateScore();
      return false; // signal to remove this raindrop
    }
    return true; // keep raindrop in array
  }

  draw() {
    ctx.fillStyle = "blue";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Snake {
  constructor() {
    this.segments = [];
    this.segmentSize = 14;
    this.length = 20;
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
    this.speed = 3;

    // initialize body
    for (let i = 0; i < this.length; i++) {
      this.segments.push({ x: this.x - i * this.segmentSize, y: this.y });
    }
  }

  update() {
    // move toward mouse
    let dx = mouse.x - this.x;
    let dy = mouse.y - this.y;
    let dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 1) {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }

    // body follows
    this.segments.unshift({ x: this.x, y: this.y });
    while (this.segments.length > this.length) {
      this.segments.pop();
    }

    // check collisions with shapes
    this.checkCollisions();
  }

  checkCollisions() {
    const eatRange = this.segmentSize;

    function overlaps(a, b, size) {
      return (
        a.x < b.x + size &&
        a.x + size > b.x &&
        a.y < b.y + size &&
        a.y + size > b.y
      );
    }

    // eat balls
    balls = balls.filter(b => {
      if (overlaps({x:this.x,y:this.y}, {x:b.x-b.radius,y:b.y-b.radius}, b.radius*2)) {
        this.discountPrices();
        return false; // remove ball
      }
      return true;
    });

    // eat squares
    squares = squares.filter(s => {
      if (overlaps({x:this.x,y:this.y}, {x:s.x,y:s.y}, s.size)) {
        this.discountPrices();
        return false;
      }
      return true;
    });

    // eat triangles (approx bounding box)
    triangles = triangles.filter(t => {
      if (overlaps({x:this.x,y:this.y}, {x:t.x-t.size/2,y:t.y}, t.size)) {
        this.discountPrices();
        return false;
      }
      return true;
    });
  }

  discountPrices() {
    upgradeCost = Math.round(Math.max(1, upgradeCost * 0.995));
    autoClickerCost = Math.round(Math.max(1, autoClickerCost * 0.995));
    ballSpawnerCost = Math.round(Math.max(1, ballSpawnerCost * 0.995));
    squareSpawnerCost = Math.round(Math.max(1, squareSpawnerCost * 0.995));
    triangleSpawnerCost = Math.round(Math.max(1, triangleSpawnerCost * 0.995));
    incomeCost = Math.round(Math.max(1, incomeCost * 0.995));
    rebirthCost = Math.round(Math.max(1, rebirthCost * 0.995));
    updateShop();

    const popup = document.createElement("div");
    popup.textContent = "-0.5%";
    popup.className = "discount-popup";
    document.body.appendChild(popup);
    setTimeout(() => popup.remove(), 1000);
  }

  draw(ctx) {
    ctx.save(); // save canvas state

    // Blue gradient body
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, "#1E90FF"); // light blue
    gradient.addColorStop(1, "#104E8B"); // deep blue
    ctx.fillStyle = gradient;

    for (let i = 0; i < this.segments.length; i++) {
      const { x, y } = this.segments[i];  // ✅ fixed

      // Wave motion for serpentine look
      const wave = Math.sin((Date.now() / 200) + i * 0.5) * 5;

      if (i === 0) {
        // Head
        ctx.fillStyle = "#104E8B"; // darker head
        ctx.beginPath();
        ctx.arc(x + wave, y, this.segmentSize * 1.2, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(x - 4, y - 4, 2, 0, Math.PI * 2);
        ctx.arc(x + 4, y - 4, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = gradient; // reset for body
      } else {
        // Body ovals
        ctx.beginPath();
        ctx.ellipse(
          x + wave,
          y,
          this.segmentSize,
          this.segmentSize * 0.7,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();
      }
    }

    ctx.restore(); // restore canvas state
  }
}
// ----- SHARK -----
class Shark {
  constructor(
    x = canvas.width / 2 + (Math.random() * 100),
    y = canvas.height / 2 + (Math.random() * 100),
    dx = null, dy = null) {
    this.x = x;
    this.y = y;
    this.electrified = false;
    this.dx = dx !== null ? dx : (Math.random() * 2 - 1) * autoClickerLevel * 1.5;
    this.dy = dy !== null ? dy : (Math.random() * 2 - 1) * autoClickerLevel * 1.5;
    this.size = 80; // overall shark size
  }

  update() {  
    this.x += this.dx;
    this.y += this.dy;

    // bounce and gain points
    if (this.x <= 0 || this.x + this.size >= canvas.width) {
      this.dx *= -1;
      let gained = Math.round(sharkValue) * multi * income;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      sharkValue += 0.1;
      updateScore();
    }

    if (this.y <= 0 || this.y + this.size >= canvas.height) {
      this.dy *= -1;
      let gained = Math.round(sharkValue) * multi * income;
      if (this.electrified) {
        gained *= shockedMultiplier;
      }
      score += gained;
      pointsThisInterval += gained;
      popups.push(new Popup(this.x, this.y, gained));
      sharkValue += 0.1;
      updateScore();
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);

    if (this.electrified) {
      ctx.shadowColor = "lightblue";
      ctx.shadowBlur = 100; // steady glow
      ctx.fillStyle = "#33ccff"; // brighter neon blue when shocked
    } else {
      ctx.fillStyle = "blue"; // normal shark color
    }

    // Body
    ctx.beginPath();
    ctx.moveTo(0, 0);                   
    ctx.lineTo(this.size * 0.8, this.size * 0.3);  
    ctx.lineTo(this.size, this.size * 0.5);        
    ctx.lineTo(this.size * 0.8, this.size * 0.7);  
    ctx.lineTo(0, this.size * 0.5);      
    ctx.closePath();
    ctx.fill();

    // Eye (white)
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(this.size * 0.2, this.size * 0.35, 3, 0, Math.PI * 2);
    ctx.fill();

    // Pupil (black)
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(this.size * 0.2, this.size * 0.35, 1.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

class Cloud {
  constructor(x, y, d) {
    this.x = x;
    this.y = y;
    this.d = d;
    this.color = "white";
    this.speed = 0.3 + Math.random() * Math.random() * 6; // gentle random speed
  }

  update() {
    this.x += this.speed * this.d;
    // when cloud goes off screen, loop it back to left
    if (this.x - 135 > canvas.width) {
      this.x = -135;
    }
    if (this.x + 135 < 0) {
      this.x = canvas.width + 135;
    }
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.save();
    ctx.scale(1.8, 1);

    ctx.beginPath();
    ctx.arc(this.x / 1.8, this.y - 10, 60, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.arc((this.x - 70) / 1.8, this.y + 10, 45, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.arc((this.x + 70) / 1.8, this.y + 10, 45, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

class Lightning {
  constructor(cloudX, cloudY) {
    this.x = cloudX; 
    this.y = cloudY;
    this.segments = [];
    this.alpha = 1; 
    this.createBolt();
  }

  createBolt() {
    let x = this.x;
    let y = this.y + 50; // start just under the cloud
    this.segments.push({ x, y });

    // jagged line downward
    while (y < canvas.height - 50) {
      x += (Math.random() - 0.5) * 40; // zig-zag horizontally
      y += Math.random() * 40 + 20;   // move down
      this.segments.push({ x, y });
    }
  }

  update() {
    this.alpha -= 0.05; // fade out quickly

    // check lightning touching shapes
    for (let shape of [...balls, ...squares, ...triangles, ...sharks]) {
      for (let seg of this.segments) {
        let dx = seg.x - shape.x;
        let dy = seg.y - shape.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 30 && Math.random() <= 0.03) { // 3% chance
          shape.electrified = true;
        }
      }
    }

    return this.alpha > 0;
  }

  draw() {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.strokeStyle = "yellow";
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 16;
    ctx.lineWidth = 14;
    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);
    for (let p of this.segments) {
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
  }
}

function checkSaveVersion() {
  const currentVersion = localStorage.getItem("save_version");

  if (currentVersion !== SAVE_VERSION) {
    // Reset all saved data
    localStorage.clear();

    // Set new version so it won't reset again until you bump it
    localStorage.setItem("save_version", SAVE_VERSION);

    console.log("Progress reset due to update.");
  }
}
                                        // Click + upgrades            //ENDD OF  CLASSES!!!!!
function addPoint() {
  
  let points = pointsPerClick * multi;
  score += points;
  pointsThisInterval += points;
  if (Math.random() < 0.4) {
    const plusOnePopup = new Popup(mouse.x, mouse.y - 10, points);
    popups.push(plusOnePopup);
  }

  updateScore();
}

function buyUpgrade() {                   //UPGRADE CLICK
  if (score >= upgradeCost) {
    score -= upgradeCost;
    pointsPerClick++;
    if (upgradeCost > 10000000) {//10 mil
      upgradeCost = Math.floor(upgradeCost * 1.35);
    }
    else {
      upgradeCost = Math.floor(upgradeCost * 1.75);
    }
    updateShop();
    updateScore();
  }
}

function buyAutoClicker() {             //upgrade speed!
  if (score >= autoClickerCost) {
    score -= autoClickerCost;
    autoClickerLevel++;
    balls.forEach(b => { b.dx *= 1.2; b.dy *= 1.2; });
    squares.forEach(s => { s.dx *= 1.2; s.dy *= 1.2; });
    triangles.forEach(s => { s.dx *= 1.2; s.dy *= 1.2; });
    if (upgradeCost > 10000000) {//10 mil
      autoClickerCost = Math.floor(autoClickerCost * 1.67);
    }
    else {
      autoClickerCost = Math.floor(autoClickerCost * 2.83);
    }
    updateShop();
    updateScore();
  }
}

function buyBallSpawner() {                 //more balls!
  if (score >= ballSpawnerCost) {
    score -= ballSpawnerCost;
    ballSpawnerCount++;
    ballSpawnerCost = Math.floor(ballSpawnerCost * 1.2);
    balls.push(new Ball());
    updateShop();
    updateScore();
  }
}

function buySquareSpawner() {               //MORE SQUARES
  if (score >= squareSpawnerCost) {
    score -= squareSpawnerCost;
    squareSpawnerCount++;
    squareSpawnerCost = Math.floor(squareSpawnerCost * 1.3);
    squares.push(new Square());
    updateShop();
    updateScore();
  }
}

function buyTriangleSpawner() {           //MORE TRIANGLES
  if (score >= triangleSpawnerCost) {
    score -= triangleSpawnerCost;
    triangleSpawnerCount++;
    triangleSpawnerCost = Math.floor(triangleSpawnerCost * 1.55);
    triangles.push(new Triangle());
    updateShop();
    updateScore();
  }
}

function buyIncome() {           //mORE VALUE LETS GO BABY!
  if (score >= incomeCost) {
    if (incomeCost > 10000000) {
      incomeCost = Math.floor(incomeCost * 1.7);
    }
    else {
      incomeCost = Math.floor(incomeCost * 1.3);
    }
      score -= incomeCost;
      income++;
      squareValue += 2;
      triangleValue += 5;
      updateShop();
      updateScore();
  }
}

//                          UPDATES AND ANIMATION
function animate() {                  //ANIMATION!
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  balls.forEach(ball => { 
    ball.update(); 
    ball.draw(); 
  });

  squares.forEach(square => { 
    square.update(); 
    square.draw(); 
  });

  triangles.forEach(triangle => {
    triangle.update();
    triangle.draw();
  });

    sharks.forEach(s => {
  s.update();
  s.draw();
  });
  
  raindrops = raindrops.filter(drop => {
    const alive = drop.update();
    drop.draw();
    return alive;
  });

  if (snake) {
  snake.update();
  snake.draw(ctx);
  }

  clouds.forEach(cloud => {
    cloud.update();
    cloud.draw();
  });
  
  if (boughtLightning) {
    if (Math.random() < lightningInterval && clouds.length > 0) {   //original: < 0.005
      let c = clouds[Math.floor(Math.random() * clouds.length)];
      let bolt = new Lightning(c.x, c.y);
      lightnings.push(bolt);
      // ⚡ bonus points happen right here, first frame only
      score += 500 * multi * income;
      pointsThisInterval += 500 * multi * income;
      updateScore();
    }

    lightnings = lightnings.filter(l => {
      const alive = l.update();
      l.draw();
      return alive;
    });
  }

  popups.forEach((p, index) => {
  p.update();
  p.draw();
  if (p.alpha <= 0) popups.splice(index, 1);
  });

  requestAnimationFrame(animate);
}

function updateShop() {           //UPDATE THE SHOP
  document.getElementById("upgradeBtn").innerText = "Upgrade Click (+" + pointsPerClick + ") — Cost: " + formatNumber(upgradeCost);
  document.getElementById("autoClickerBtn").innerText = "Upgrade Speed (Lv " + autoClickerLevel + ") — Cost: " + formatNumber(autoClickerCost);
  document.getElementById("ballSpawnerBtn").innerText = "Add Ball (Now " + ballSpawnerCount + ") — Cost: " + formatNumber(ballSpawnerCost);
  document.getElementById("squareSpawnerBtn").innerText = "Add Square (Now " + squareSpawnerCount + ") — Cost: " + formatNumber(squareSpawnerCost);
  document.getElementById("incomeBtn").innerText = "Increase Value (Now " + income + ") — Cost: " + formatNumber(incomeCost);
  document.getElementById("triangleSpawnerBtn").innerText = "Add Triangle (Now " + triangleSpawnerCount + ") — Cost: " + formatNumber(triangleSpawnerCost);
  document.getElementById("sharkSpawnerBtn").innerText = "Add Shark (Now " + sharkSpawnerCount + ") — Cost: " + formatNumber(sharkSpawnerCost);
  document.getElementById("rebirth").innerText = "REBIRTH (Multi:  " + multi + ") — Cost: " + rebirthCost;

} 

function updateScore() {
  // Check for insane numbers and restart
  if (score > 1e200) {
    restartGame();
  }

  // Unlock more upgrades if score is high enough
  if (score >= 1000000 && !unlockedMoreUpgrades) {
    unlockedMoreUpgrades = true;
    document.getElementById("MoreUpgradesButton").style.display = "block";
  }

  // Update UI with commas
  document.getElementById("score").innerText = "Score: " + formatNumber(score);
  document.getElementById("multiplier").innerText = "×" + multi;

  // Save automatically
  saveGame();
}

// ----------------- Save / Load -----------------
function saveGame() {
  const saveData = {
    score, pointsPerClick, upgradeCost,
    autoClickerLevel, autoClickerCost,
    ballSpawnerCount, ballSpawnerCost,
    squareSpawnerCount, squareSpawnerCost,
    triangleSpawnerCount, triangleSpawnerCost,
    income, incomeCost,
    squareValue, triangleValue,
    balls: balls.map(b => ({x: b.x, y: b.y, dx: b.dx, dy: b.dy})),
    squares: squares.map(s => ({x: s.x, y: s.y, dx: s.dx, dy: s.dy})),
    triangles: triangles.map(t => ({x: t.x, y: t.y, dx: t.dx, dy: t.dy})),
    sharks: sharks.map(t => ({x: t.x, y: t.y, dx: t.dx, dy: t.dy})),
    multi, rebirthCost, growingCostMulti,
    unlockedMoreUpgrades,
    rainSpeed, boughtRain,
    boughtSnake, snake,
    pickedWater,
    sharkSpawnerCost, sharkSpawnerCount, sharkValue,
    boughtClouds, boughtLightning, lightningInterval,
    shockedMultiplier, upgradedLightning
  };
  localStorage.setItem("clickerSave", JSON.stringify(saveData));
}

function loadGame() {
  const saved = JSON.parse(localStorage.getItem("clickerSave"));
  if (saved) {
    score = saved.score || 0;
    pointsPerClick = saved.pointsPerClick || 1;
    upgradeCost = saved.upgradeCost || 10;
    autoClickerLevel = saved.autoClickerLevel || 1;
    autoClickerCost = saved.autoClickerCost || 50;

    ballSpawnerCount = saved.ballSpawnerCount || 0;
    ballSpawnerCost = saved.ballSpawnerCost || 100;

    squareSpawnerCount = saved.squareSpawnerCount || 0;
    squareSpawnerCost = saved.squareSpawnerCost || 200;

    triangleSpawnerCount = saved.triangleSpawnerCount || 0;
    triangleSpawnerCost = saved.triangleSpawnerCost || 500;

    income = saved.ballValue || 1;
    squareValue = saved.squareValue || 2;
    triangleValue = saved.triangleValue || 5;
    incomeCost = saved.incomeCost || 1000;

    multi = saved.multi || 1;
    rebirthCost = saved.rebirthCost || 100000;
    growingCostMulti = saved.growingCostMulti || 1.5;

    unlockedMoreUpgrades = saved.unlockedMoreUpgrades || false;
    raindrops = saved.raindrops || [];
    rainSpeed = saved.rainSpeed || 200;
    boughtRain = saved.boughtRain || false;
    boughtClouds = saved.boughtClouds || false;
    boughtLightning = saved.boughtLightning || false;
    lightningInterval = saved.lightningInterval || false;
    boughtSnake = saved.boughtSnake || false;
    upgradedLightning  = saved.upgradedLightning || false;

    shockedMultiplier = saved.shockedMultiplier || false;

    pickedWater = saved.pickedWater || false;
    
    if (boughtSnake) snake = new Snake();

    //hide buttons
    if (boughtRain == true) {
      document.getElementById("rain").style.display = "none";
      startRain();
    }
    if (boughtClouds == true) {
      clouds.push(new Cloud(100, 33, -1));
      clouds.push(new Cloud(300, 40, 1));
      clouds.push(new Cloud(600, 35, 1));
      clouds.push(new Cloud(700, 30, -1));
      clouds.push(new Cloud(800, 35, 1));
      clouds.push(new Cloud(1000, 30, -1));
      clouds.push(new Cloud(1300, 32, -1));
      clouds.push(new Cloud(1500, 41, 1));
      clouds.push(new Cloud(1700, 38, -1));
      clouds.push(new Cloud(2000, 40, -1));
      document.getElementById("cloudsBtn").style.display = "none";
    }
    if (boughtLightning == true) {
      for (let cloud of clouds) {
        let gradient = ctx.createLinearGradient(cloud.x, cloud.y, cloud.x, cloud.y + 50);
        gradient.addColorStop(0, "#aaa"); // lighter top
        gradient.addColorStop(1, "#444"); // darker bottom
        cloud.color = gradient; // store gradient properly
    }
    }
    if (unlockedMoreUpgrades == true) {
      document.getElementById("MoreUpgradesButton").style.display = "block";
      if (pickedPath == true) {
        if (pickedWater == false) {
          document.getElementById("pathLabel").style.display = "block";  //PATHS: label
          document.getElementById("waterPathBtn").style.display = "block";
        }
      }
      // if (pickedWater == true) {
      //   document.getElementById("rain").style.display = "block";
      //   document.getElementById("snakeBtn").style.display = "block";
      //   document.getElementById("MoreUpgradesButton").style.display = "block";
      //   document.getElementById("sharkSpawnerBtn").style.display = "block";
        
      // }
    }


    // Restore balls/squares/triangles (optional)
    balls = (saved.balls || []).map(b => new Ball(b.x, b.y, b.dx, b.dy));
    squares = (saved.squares || []).map(s => new Square(s.x, s.y, s.dx, s.dy));
    triangles = (saved.triangles || []).map(t => new Triangle(t.x, t.y, t.dx, t.dy));
  } else {
    // If no save, initialize default objects
    balls = [];
    for (let i = 0; i < ballSpawnerCount; i++) balls.push(new Ball());
    squares = [];
    triangles = [];
    raindrops = [];
    clouds = [];
    sharks = [];
  }
  restorePaths();
  startRain();
  updateShop();
  updateScore();
}

function restartGame() {
  if (rainInterval) {
    clearInterval(rainInterval); // stop the rain
    rainInterval = null;         // reset so it can start again later
  }

  if ('scrollRestoration' in history) {   // to go to top when start
  history.scrollRestoration = 'manual';
  }

  window.onload = function() {
    window.scrollTo(0, 0);
  };

  pickedWater = false;

  multi = 1;
  score = 0;
  pointsPerClick = 1;
  upgradeCost = 10;
  autoClickerLevel = 1;
  autoClickerCost = 50;

  ballSpawnerCount = 0;
  ballSpawnerCost = 100;

  squareSpawnerCount = 0;
  squareSpawnerCost = 200;

  triangleSpawnerCount = 0;
  triangleSpawnerCost = 500;

  income = 1;
  squareValue = 2;
  triangleValue = 5;
  incomeCost  = 1000;

  balls = [];
  squares = [];
  triangles = [];
  raindrops = [];
  sharks = [];
  clouds = [];
  lightning = [];

  growingCostMulti = 1.5;
  rebirthCost = 100000;
  unlockedMoreUpgrades = false;
  rainSpeed = 200;
  boughtRain = false;
  boughtClouds = false;
  boughtLightning = false;
  lightningInterval = 0.01;
  upgradedLightning = false;

  shockedMultiplier = 50;
  
  sharkSpawnerCount = 0;
  sharkSpawnerCost = 15000000;
  sharkValue = 10;    

  removeSnake(); //sets all snake variables to false and deletes snake

  //HIDE THE UPGRADES
  document.getElementById("rain").style.display = "none";
  document.getElementById("MoreUpgradesButton").style.display = "none";
  document.getElementById("pathLabel").style.display = "none";
  document.getElementById("snakeBtn").style.display = "none";
  document.getElementById("sharkSpawnerBtn").style.display = "none";
  document.getElementById("waterPathBtn").style.display = "none";
  document.getElementById("cloudsBtn").style.display = "none";
  document.getElementById("lightningBtn").style.display = "none";
  document.getElementById("lightningUpgradeBtn").style.display = "none";

  updateShop();
  updateScore();
  saveGame();
}

//                                  CUSTOM STUFF!

function restorePaths() {
  if (pickedWater == true) {
    document.getElementById("waterPathBtn").style.display = "none";
    if (boughtRain == false) {
    document.getElementById("rain").style.display = "block";
    }
    if (boughtSnake == false) {
      document.getElementById("snakeBtn").style.display = "block";
    }
    if (boughtClouds == false && boughtRain == true) {
      document.getElementById("cloudsBtn").style.display = "block";
    }
    if (boughtLightning == false && boughtClouds == true) {
      document.getElementById("lightningBtn").style.display = "block";
    }
    if (upgradedLightning == false && boughtLightning == true) {
      document.getElementById("lightningUpgradeBtn").style.display = "block";
    }
  }
}

function wait(ms) { 
  return new Promise(resolve => setTimeout(resolve, ms));
}

function formatNumber(num) {
  if (num < 1e9) {
    // Below a billion → commas only
    return Math.floor(num).toLocaleString();
  }

  // Units starting at Billion
  const units = ["B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"];
  let unitIndex = 0;

  // First step: make billions the baseline
  num /= 1e9;

  // Now scale by 1000 for larger units
  while (num >= 1000 && unitIndex < units.length - 1) {
    num /= 1000;
    unitIndex++;
  }

  return parseFloat(num.toFixed(2)) + units[unitIndex];
}

async function rebirth() {  
  if (score >= rebirthCost) { // check cost
    multi += 1;
    document.getElementById("rebirth").style.display = "none";
    const multiEl = document.getElementById("multiplier");
    multiEl.classList.add("animate-multi");
    setTimeout(() => multiEl.classList.remove("animate-multi"), 1005);

    let cur_score = score;
    
    while (score > 0) {
      score -= getRandom(0.001 * cur_score, 0.01 * cur_score);
      updateScore();
      if (score < 0) 
        score = 0;
        updateScore();
        await wait(1);
    }
    score = 0;
    cur_score = 0;
    pointsPerClick = 1;
    upgradeCost = 10;
    autoClickerLevel = 1;
    autoClickerCost = 50;

    ballSpawnerCount = 0;
    ballSpawnerCost = 100;

    squareSpawnerCount = 0;
    squareSpawnerCost = 200;

    triangleSpawnerCount = 0;
    triangleSpawnerCost = 500;

    sharkSpawnerCount = 0;
    sharkSpawnerCost = 15000000;
    sharkValue = 10; 

    ballValue = 1;
    squareValue = 2;
    triangleValue = 5;
    incomeCost = 1000;
    income = 1;

    balls = [];
    squares = [];
    triangles = [];
    raindrops = [];
    sharks = [];
    clouds = [];
    lightning = [];

    unlockedMoreUpgrades = false;
    rainSpeed = 200;
    boughtRain = false;
    boughtClouds = false;
    boughtLightning = false;
    lightningInterval = 0.01;
    upgradedLightning = false;

    shockedMultiplier = 50;

    if (rainInterval) {
        clearInterval(rainInterval); // stop the rain
        rainInterval = null;         // reset
      }
      removeSnake();

      let newRebirthCost = rebirthCost * growingCostMulti;
      if (newRebirthCost < 10000000) {
        growingCostMulti *= 1.9;
      }
      if (newRebirthCost >= 10000000 && newRebirthCost <= 100000000) {
        growingCostMulti *= 1.3;
      }
      else {
        growingCostMulti *= 1.1;
      }
      rebirthCost = Math.floor(newRebirthCost);

      document.getElementById("rebirth").style.display = "block";
      document.getElementById("rain").style.display = "none";
      document.getElementById("MoreUpgradesButton").style.display = "none";
      document.getElementById("pathLabel").style.display = "none";
      document.getElementById("snakeBtn").style.display = "none";
      document.getElementById("sharkSpawnerBtn").style.display = "none";
      document.getElementById("waterPathBtn").style.display = "none";
      document.getElementById("cloudsBtn").style.display = "none";
      document.getElementById("lightningBtn").style.display = "none";
      document.getElementById("lightningUpgradeBtn").style.display = "none";
      updateShop();
      updateScore();
      saveGame();
  }
}

function getRandom(min, max) {       //random number function!!!!
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function showButtons() {
  document.getElementById("MoreUpgradesButton").style.display = "none";
  document.getElementById("pathLabel").style.display = "block";
  unlockedMoreUpgrades = false;
  if (pickedPath == false) {
    document.getElementById("waterPathBtn").style.display = "block";
  }
}

function waterPath() {
  document.getElementById("pathLabel").style.display = "none"; //hide the path label
  waterPathBtn.classList.add("fade");
  waterPathBtn.style.pointerEvents = "none";
  waterPathBtn.addEventListener("animationend", () => {
  waterPathBtn.style.display = "none";
  waterPathBtn.classList.remove("fade");
  }, { once: true });

  if (boughtRain == false) {
    document.getElementById("rain").style.display = "block";
  }
  if (boughtSnake == false) {
    document.getElementById("snakeBtn").style.display = "block";
  }
  if (boughtClouds == false && boughtRain == true) {
    document.getElementById("cloudsBtn").style.display = "block";
  }
  if (boughtLightning == false && boughtClouds == true) {
    document.getElementById("lightningBtn").style.display = "block";
  }
  document.getElementById("sharkSpawnerBtn").style.display = "block";
}

function createRaindrop() {
  raindrops.push(new Raindrop());
}

function startRain() {
  if (boughtRain && !rainInterval) { // only start if not already running
    rainInterval = setInterval(createRaindrop, rainSpeed);
  }
}

function buyRain() {
  const rainCost = 1000000;
  const rainBtn = document.getElementById("rain");
  const snakeBtn = document.getElementById("snakeBtn");

  if (score >= rainCost && !boughtRain) {
    score -= rainCost;
    boughtRain = true;
    startRain(); 
    updateScore();
    document.getElementById("cloudsBtn").style.display = "block";

    // fade rain button out
    rainBtn.classList.add("fade");
    rainBtn.style.pointerEvents = "none"; // prevent clicks
    rainBtn.addEventListener("animationend", () => {
      rainBtn.style.display = "none";
      rainBtn.classList.remove("fade");
    }, { once: true });
  }
}

function buySnake() {
  const snakeBtn = document.getElementById("snakeBtn");

  if (score >= snakeSpawnerCost && !boughtSnake) {
    score -= snakeSpawnerCost;
    boughtSnake = true;
    snake = new Snake();
    updateScore();

    // fade out snake button when bought
    snakeBtn.classList.add("fade");
    snakeBtn.style.pointerEvents = "none";
    snakeBtn.addEventListener("animationend", () => {
      snakeBtn.style.display = "none";
      snakeBtn.classList.remove("fade");
    }, { once: true });
  }
}

function removeSnake() {
  if (snake) {
    snake = null;           // stop updating/drawing
    boughtSnake = false;    // allow buying again
    document.getElementById("snakeBtn").style.display = "none"; // hide button
  }
}

function buyClouds() {
  if (!boughtClouds && score >= 500000) { // example cost
    score -= 500000;
    boughtClouds = true;
    document.getElementById("lightningBtn").style.display = "block";

    clouds.push(new Cloud(100, -10, -1));
    clouds.push(new Cloud(300, -12, 1));
    clouds.push(new Cloud(600, -5, 1));
    clouds.push(new Cloud(700, 0, -1));
    clouds.push(new Cloud(800, -7, 1));
    clouds.push(new Cloud(1000, -10, -1));
    clouds.push(new Cloud(1300, -11, -1));
    clouds.push(new Cloud(1500, -15, 1));
    clouds.push(new Cloud(1700, -4, -1));
    clouds.push(new Cloud(2000, -8, -1));
    clouds.push(new Cloud(1900, -9, 1));
    rainSpeed = 50;
    cloudsBtn.classList.add("fade");
    cloudsBtn.style.pointerEvents = "none";
    cloudsBtn.addEventListener("animationend", () => {
    cloudsBtn.style.display = "none";
    cloudsBtn.classList.remove("fade");
    }, { once: true });
  }
}

function buySharkSpawner() {
  if (score >= sharkSpawnerCost) {
    score -= sharkSpawnerCost;
    sharks.push(new Shark());
    sharkSpawnerCost = Math.floor(sharkSpawnerCost * 1.5);
    sharkSpawnerCount += 1;
    updateShop();
    updateScore();
    saveGame();
  }
}

function buyLightning() {
  if (score >= 20000000) {
    score -= 20000000;
    boughtLightning = true;
    document.getElementById("lightningUpgradeBtn").style.display = "block";

    for (let cloud of clouds) {
      let gradient = ctx.createLinearGradient(cloud.x, cloud.y, cloud.x, cloud.y + 50);
      gradient.addColorStop(0, "#aaa"); // lighter top
      gradient.addColorStop(1, "#444"); // darker bottom
      cloud.color = gradient; // store gradient properly
    }

    lightningBtn.classList.add("fade");
    lightningBtn.style.pointerEvents = "none";
    lightningBtn.addEventListener("animationend", () => {
    lightningBtn.style.display = "none";
    lightningBtn.classList.remove("fade");
    }, { once: true });
    rainSpeed = 50;
    saveGame();
  }
}

function upgradeLightning() { 
  if (score >= 60000000) {//60 mil
    score -= 60000000;
    lightningInterval = 0.05;
    shockedMultiplier = 200;
    upgradedLightning = true;

    lightningUpgradeBtn.classList.add("fade");
    lightningUpgradeBtn.style.pointerEvents = "none";
    lightningUpgradeBtn.addEventListener("animationend", () => {
    lightningUpgradeBtn.style.display = "none";
    lightningUpgradeBtn.classList.remove("fade");
    }, { once: true });
    saveGame();
  }
}

checkSaveVersion();
loadGame();
animate(); 
</script>
</body>
</html>